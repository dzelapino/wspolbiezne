# ZAGADNIENIA NA EGZAMIN

## WATKI I PROCESY

### POJECIA PROCESU I WATKU WSPOLBIEZNEGO

#### PROCES

PROCES WSPOLBIEZNY = ILOSC ZADAN KTORE MOGA BYC WYKONYWANE ROWNOLEGLE

ZADANIE = PROCES SEKWENCYJNY CZYLI CIAG OPERACJI, OPERACJE SA WYKONYWANE PO SOBIE (LINIE W KODZIE)

PROCESY WSPOLBIEZNE TO KILKA ZADAN(PROBLEMOW SEKWENCYJNYCH) KTORYCH OPERACJE NAKLADAJA SIE W CZASIE

PROCESY WSPOLBIEZNE MOGA BYC WYKONYWANE JEDNOCZESNIE JEZELI SA WYKONYWANE PRZEZ OSOBNE PROCESORY

METODA PRZEPLOTU = PROCESOR REALIZUJE OBLICZENIA WIELU PROCESOW DOKONUJAC PODZIALU CZASU MIEDZY ZADANIAMI OD ROZNYCH PROCESOW

PROCESY WSPOLBIEZNE MOGA ROZMAWIAC ZE SOBA ZA POMOCA PAMIECI WSPOLNEJ LUB PRZESYLANIA WIADOMOSCI

PROCES JEST NADZOROWANY, TWORZONY, LIKWIDOWANY PRZEZ SYSTEM OPERACYJNY

ZASOBY PROCESU

- OBSZAR PAMIECI (PRZECHOWUJE INSTRUKCJE)
- DANE
- STOS
- ZBIOR REJESTWOR (LICZNIK INSTRUKCJI, STACK POINTER)

PROCESY SA WYKONYWANE PRZEZ WATKI ALBO ZESPOLY WATKOW

#### WATEK

WATEK TO JEDNOSTKA SYSTEMU OPERACYJNEGO REALIZUJACA NIEZALEZNY STRUMIEN INSTRUKCJI

WATKI REALIZOWANE W RAMACH PROCESU WSPOLDZIELA PRZYZNANE TEMU ZASOBOWI ZASOBY, PRZESTRZEN ADRESOWA PAMIECI

KAZDY WATEK MA WLASNE ZASOBY DO WYLACZNEGO UZYTKU (STOS, REJESTR LICZNIKA INSTRUKCJI)

### JAKIE SA ROZNICE MIEDZY NIMI

TWORZENIE PROCESU JEST BARDZIEJ OBCIAZAJACE NIZ TWORZENIE WATKU

PROCES TO JAKBY PROGRAM NATOMIAST WATEK WCHODZI W SKLAD TEGO PROCESU

WATKI ZUZYWAJA MNIEJ ZASOBOW NIZ PROCESY

WATKI SA URUCHAMIANE W RAMACH JEDNEGO PROCESU

### KOMENDY

NAZWA-PROGRAMU-CZY-COS = URUCHAMIA PROCES PIERWSZOPLANOWY

TO-SAMO-CO-WYZEJ & = TU MAMY Z AMPERSANDEM I TO URUCHAMIA PROCES DRUGOPLANOWY BEZ DOSTEPU DO TERMINALA

(TO-SAMO-CO-WYZEJ &) = TU NAWIASY ROBIA ZE ODPALA SIE Z PODPOWLOKI

CTRL-Z = ZAWIESZA PROCES PIERWSZOPLANOWY

BG ZADANIE LUB ZADANIE & = URUCHAMIA W TLE ZAWIESZONY PROCES

FG ZADANIE LUB ZADANIE = URUCHAMIA ZAWIESZONY PROCES NA PIERWSZYM PLANIE

KILL -9 ZADANIE = ZABIJA ZAWIESZONY LUB DZIALAJACY PROCES

MOZNA URUCHOMIC KILKA PROCESOW UZYWAJAC JEDNEGO POLECENIA

PROCES1 & PROCES2 &

### TWORZENIE PROCESOW Z POZIOMU SHELLA

DLA POLECENIA CAT FILE

SHELL ROBI FORKA: FORK()
PO STRONIE USERA ROBI CZEKAC: WAIT()
TAM GDZIE USER NIE WIDZI W TYM FORKU ROBI EXCAVE(): ROZGALEZIONY PROCES POKRYWA SIE Z KODEM NOWEGO POLECENIA
SYSTEM WIDZI POLECENIA CAT PLIK I TO ROBI
POLECENIE SIE KONCZY I NASTEPUJE EXIT()
I TERAZ SHELL WRACA DO KONTROLI UZYTKOWNIKA

DA SIE TAK SAMO URUCHOMIC TE POLECENIE W TLE NIE CZEKAJAC NA ZAKONCZENIE ROZGALEZIONEGO PROCESU

CAT PLIK > PLIK1 &

## PLIKI BLOKUJACE (LOCK FILE)

### SPOSOB UZYCIA PLIKOW BLOKUJACYCH DO CZEGO SLUZA

PLIKI BLOKUJACE SLUZA ABY BLOKOWAC DOSTEP ROZNYM PROCESOM DO NIEWSPOLNEGO ZASOBU NP DRUKARKA, DYSK, PLIK

UZYWAMY ICH W SPOSOB:

- USTALAMY NAZWE I MIEJSCE PLIKU
- URUCHAMIAJAC PROCES NAJPIERW PATRZYMY CZY ISTNIEJE PLIK BLOKUJACY
- JESLI NIE TO TWORZYMY PLIK I ZAJMUJEMY ZASOB
- PO SKONCZENIU UZYWANIA ZASOBU USUWAMY PLIK BLOKUJACY
- JESLI PLIK BLOKUJACY ISTNIEJE TO PROCES W PETLI CZEKA AZ PLIK ZOSTANIE USUNIETY

### DLACZEGO WAZNE JEST SPRWADZENIE CZY ISTNIEJE PLIK BLOKUJACY

JESLI NIE SPRAWDZIMY CZY LOCKFILE ISTNIEJE NASZ PROCES ZACZNIE DOBIERAC SIE DO ZASOBU KTORY JEST W TRAKCIE UZYWANIA

### UTWORZENIE PLIKU BLOKUJACEGO W PRZYPADKU NIEISTNIENIA OPERACJA NIEPODZIELNA

ZAPEWNE W PRZYPADKU OPERACJI PODZIELNEJ MOGLBY WYKONAC SIE PROCES UZYWAJACY TEGO KONKRETNEGO ZASOBU, PO CZYM PLIK SIE TWORZY I LECI DALEJ PROCES CO CHCIAL UZYWAC TEGO ZASOBU A TU LIPA, WIEC LEPIEJ STWORZYC PLIK I POTEM DZIALAC

#### OSIAGNIECIE TEGO W PYTONIE

```PYTHON
    while True:
        try:
            # próba otwarcia pliku na wyłączny użytek
            fd = os.open("plikZamkowy", os.O_CREAT|os.O_EXCL|os.O_RDWR)
            # OGOLNIE TUTAJ BYM DAL JESZCZE TIMEOUT ZEBY NIE ROBILO WZIUUUM NONSTOP
            break;
    except OSError as e:
        if e.errno != errno.EEXIST:
            raise
        time.sleep(0.05)
    print("plik zamkowy utworzony”)
        # operacje zabezpieczone plikiem zamkowym
    print("operacje zabezpieczone plikiem zamkowym")
    time.sleep(2)
        # usuwanie pliku zamkowego
    os.close(fd)
    os.unlink("plikZamkowy")
    print("koniec, plik zamkowy zlikwidowany")
```

### SZCZEGOLY PRZYKLADU

MAMY DWA PLIKI OBA RUSZAJA
MOZE SIE POJAWIC WYSCIG (DWA PROCESY STWIERDZAJA ZE NIE MA PLIKU BLOKUJACEGO I SCIGAJA SIE XD)
NO ALE WYSCIG SIE NIE POJAWIL I JEST W PYTE
PIERWSZY TWORZY LOCKFILE I SOBIE WYKONUJE OPERACJE
DRUGI WIDZI ZE JEST LOCKFILE I WYPISUJE: "O CHOLIBKA JEST LOCKFILE TO CZEKAM"
PIERWSZY SKONCZYL DZIALANIE I USUWA LOCKFILE
PETLA W DRUGIM SIE WYKONUJE I ZOBACZYLA ZE LOCKFILE ZNIKNAL WIEC NASTEPUJE BREAK PETLI
DRUGI TWORZY LOCKFILE I WYKONUJE PRACE NA TYM PLIKU CO JEST WSPOLDZIELONY
DRUGI USUWA LOCKFILE PO SKONCZONEJ PRACY

## TWORZENIE PROCESOW I PRYMITYWNE SPOSOBY ICH SYNCHRONIZACJI

### DZIALANIE FORK, EXIT, WAIT MODULU OS W PYTHONIE

#### FORK

TWORZY PROCES-POTOMEK KTORY ROZNI SIE OD RODZICA TYLKO NUMERAMI:

- PID : PROCESS ID
- PPID : PARENT PID

I JESZCZE TYM ZE INFORMACJE STATYSTYCZNE SA WYZEROWANE

FUNKCJA ZWRACA WARTOSC:

- W PROCESIE MACIERZYSTYM(OJCU): PID UTWORZONEGO POTOMKA (WARTOSC > 0)
- W PROCESIE SYNU: WARTOSC 0
- W PRZYPADKU BLEDU ZWRACA WARTOSC -1 (TYLKO W OJCU)

W PYTONIE ZEBY UZYC FUNKCJI SYSTEMOWEJ:

MODUL OS
OS.FORK()
ISTNIEJA TEZ INNE MODULY POZWALAJACE TWORZYC NOWE PROCESY(MULTIPROCESSING)

#### EXIT

FUNKCJA SYSTEMOWA EXIT(), _EXIT()

VOID _EXIT(INT STATUS) = KONCZY DZIALANIE PROCESU I PRZESYLA JEDNOBAJTOWA LICZBE (KOD WYJSCIA 0/1) DO PROCESU RODZICIELSKIEGO

VOID EXIT(INT STATUS) = TAKI SAM JAK GOSC POWYZEJ ALE MA FUNKCJE SPRZATAJACE

```PYTHON
os._exit() # WYWOLUJE FUNKCJE SYSTEMOWA _EXIT()

sys.exit() # DZIALA JAK SYSTEMOWY EXIT()
```

#### WAIT

ZAWIESZA PROCES W OCZEKIWANIU NA ZAKONCZENIE PROCESU POTOMNEGO, ODBIERA KOD WYJSCIA PROCESU POTOMNEGO

```PYTHON
pid_t wait(int *wstatus);
pid_t waitpid(pid_t pid, int *wstatus, int options)
```

#### SZCZEGOLY PRZYKLADOW

FORK

```PYTHON
import os
import time
import errno
# rozgałęziamy proces
pid = os.fork()
# niezerowy pid oznacza, że jesteśmy w procesie macierzystym
if pid>0 :
    print("ojciec: mój PID: ", os.getpid())
    print("ojciec: pid stworzonego syna: ",pid)
    print("ojciec: kontynuuacja działania")
    time.sleep(1)
    print("ojciec: kończę")
elif pid == 0:
    print("syn: zaczynam")
    print("syn: mój PID: ", os.getpid())
    time.sleep(1)
    print("syn: kończę")
else:
    print("ojciec: błąd przy tworzeniu procesu")
```

EXIT I WAIT

```PYTHON
import os
import time
import sys
# rozgałęziamy proces
pid = os.fork()
# niezerowy pid oznacza, że jesteśmy w procesie macierzystym
if pid>0 :
    print("ojciec: pid stworzonego syna: ",pid)
    # czekanie na zakończenie (jakiegoś) syna
    status = os.wait()
    print("ojciec: PID procesu zakończonego:", status[0])
    if os.WIFSIGNALED(status[1]):
        print("ojciec: Sygnał, który zabił proc. syna",status[1])
    if os.WIFEXITED(status[1]):
        print("ojciec: zwrócony kod powrotu syna ",
            os.WEXITSTATUS(status[1]))
else :
    print("syn: zaczynam")
    print("syn: mój PID: ", os.getpid())
    time.sleep(2)
    print("syn: kończę")
    os._exit(11)
    # sys.exit(11)
```

W TYM PRZYKLADZIE Z WAIT I EXIT
OJCIEC WYPISUJE PID STWORZONEGO SYNA (6049)
SYN ZACZYNA
SYN WYPISUJE SWOJE PID (6049)
SYN KONCZY
OJCIEC WYPISUJE PID PROCESU KTORY SIE SKONCZYL (6049)
OJCIEC WYPISUJE ZWROCONY KOD POWROTU SYNA (11)

MIMO TEGO ZE OJCIEC NIE MUSIAL JUZ NIC WYKONYWAC PRZEZ WAIT CZEKAL AZ SYN SKONCZY SWOJE OPERACJE

JESLI ZROBIMY KILL NA PROCES SYNA (JAKO ZE W KILL PODAJEMY -9: KILL -9 6049)
TO OJCIEC WYPISZE:
PID PROCESU KTORY SIE SKONCZYL (6049)
SYGNAL ZABICIA SYNA (9)

## KLASYCZNE PROBLEMY PROGRAMOWANIA WSPOLBIEZNEGO (WZAJEMNE WYKLUCZANIE)

PRZYKLAD:
    P_I:
        WHILE TRUE
            SEKCJA_LOKALNA_I
            PROTOKOL_WEJSCIOWY_I
            SEKCJA_KRYTYCZNA_I
            PROTOKOL_WYJSCIOWY_I

WZAJEMNE WYKLUCZANIE: ZADNE DWA PROCESY NIE MOGA BYC ROWNOCZESNIE W SWOICH SEKCJACH KRYTYCZNYCH

ZATRZYMANIE SIE KTOREGOS Z PROCESOW W JEGO SEKCJI LOKALNEJ NIE MOZE ZAKLOCIC DZIALANIA INNYCH PROCESOW ( ICH MOZLIWOSCI WCHODZENIA DO ICH SEKCJI KRYTYCZNYCH )

BRAK BLOKADY

BRAK ZAGLODZENIA

JEZELI PROCES CHCE WEJSC DO SEKCJI KRYTYCZNEJ A INNE NIE TO WEJDZIE DO NIEJ

### PROBLEM WZAJEMNEGO WYKLUCZANIA

ALGORYTMY WZAJEMNEGO WYKLUCZENIA (MUTEX - MUTUAL EXCLUSION) SA UZYWANE W CELU UNIKNIECIA ROWNOCZESNEGO UZYCIA ZASOBU NP: ZMIENNEJ GLOBALNEJ PRZEZ ROZNE WATKI/PROCESY W CZESCIACH KODU ZWANYCH SEKCJAMI KRYTYCZNYMI

SEKCJA KRYTYCZNA TO FRAGMENT KODU W KTORYM WATKI LUB PROCESY ODWOLUJA SIE DO WSPOLNEGO ZASOBY

### POJECIE BLOKADY (DEADLOCK)

BLOKADY TO MUTEX SA TO OBIEKTY NEGUJACE DOSTEP POMIEDZY WATKAMI
BLOKADA TO MECHANIZM ZAPOBIEGAJACY KONFLIKTOM W DOSTEPIE DO ZASOBOW

ZADANIE (PROCES/WATEK) PRZED UZYSKANIEM DOSTEPU DO ZASOBU MUSI UZYSKAC DLA SIEBIE BLOKADE TEGO ZASOBU (NIKT INNY GO NIE UZYJE) NASTEPNIE PO ZAKONCZENIU WYKORZYSTYWANIA GO ZWOLNIC BLOKADE UDOSTEPNIAJAC ZASOB INNYM ZADANIOM

### POJECIE ZAGLODZENIA

ZAGLODZENIE NASTEPUJE WTEDY GDY PROCES NIE JEST W STANIE ZAKONCZYC DZIALANIA PONIEWAZ NIE MA DOSTEPU DO WSPOLDZIELONEGO ZASOBU

BRAK ZAGLODZENIA JEST WTEDY GDY PROCES PODEJMUJE PROBE WEJSCIA DO SWOJEJ SEKCJI KRYTYCZNEJ I W KONCU DO NIEJ WCHODZI

### ZNACZENIE OPERATOROW ⧠ I ♢ LOGIKI TEMPORALNEJ

LOGIKA TEMPORALNA TO ZBIOR CIAGOW PRZEJSC DO KOLEJNYCH STANOW OBLICZENIA
(S0 -> S1 -> S2 -> S3 -> ...)
W KAZDYM ZE STANOW MAMY OKRESLONE WARTOSCIOWANIE ZMIENNYCH PROGRAMU I MIEJSCE GDZIE JESTESMY W PROGRAMIE WIEC MOZEMY TWORZYC FORMULY:

FORMULA: JEZELI PROCES_1 JEST PRZED WEJSCIEM DO SEKCJI KRYTYCZNEJ TO K_1 = 0
I SPRAWDZAC W JAKIM STANIE S FORMULA JEST PRAWDZIWA CZY NIE

ROMB FORMULA: KIEDYS FORMULA BEDZIE PRAWDZIWA
KWADRAT FORMULA: FORMULA JEST ZAWSZE PRAWDZIWA

KIEDYS I ZAWSZE ODNOSZA SIE DO STANOW NASTEPUJACYCH OD BIEZACEGO STANU LACZNIE Z BIEZACYM STANEM

TAKIE FORMULY MOZEMY LACZYC ZWYKLYMI SPOJNIKAMI LOGICZNYMI

PRZYKLAD:

WHILE TRUE || WHILE TRUE
X = X + 1  || Y = X
           || X = 1

S0 -> S1 -> S2 -> S3 -> ...
S0: X = 1, Y = 0
S1: X = 2, Y = 0 (WYKONAL SIE PIERWSZY PROCES TEN  LEWEJ)
S2: X = 2, Y = 2 (WYKONALA SIE 1 LINIJKA PROCESU 2)
S3: X = 1, Y = 2 (2 LINIJKA PROCESU 2)

⧠♢ x=1 - zawsze jest tak, że kiedyś x=1 (KWADRAT ROMB)
♢⧠ y>0 - kiedyś będzie tak, że zawsze d tego miejsca y>0 (ROMB KWADRAT)
⧠ ( x=3 => ♢y>= 3) (KWADRAT W SRODKU ROMB)

### WYZNACZYC KONCEPCJE SEMAFORA (SIGNAL, WAIT)

SEMAFOR TO ZMIENNA CALKOWITA PRZYJMUJACA WARTOSCI NIEUJEMNE

SEMAFOR MA DWA RODZAJE OPERACJI (PODNOSZENIE CZYLI ZWIEKSZENIE I OPUSZCZANIE CZYLI ZMNIEJSZENIE) OGOLNIE SEMAFORY DZIALAJA TAK ZE JAKAS OPERACJA POWODUJACA ZMNIEJSZENIE MOZE BYC ZABLOKOWANA AZ WARTOSC NA SEMAFORZE NIE ZWIEKSZY SIE NA TYLE ZE ZMNIEJSZENIE TO NIE SPOWODUJE WARTOSCI UJEMNEJ

WAIT(S) JEZELI S>0 TO WYKONAJ S=S-1, W INNYM RAZIE WYKONYWYANIE PROCESU KTORY ZROBI OPERACJE WAIT JEST WSTRZYMANE, TAKI PROCES JEST NAZYWANY WSTRZYMANYM NA SEMAFORZE S

SINGAL(S) JEZELI JAKIES PROCESY SA WSTRZYMANE NA SEMAFORZE S TO WZNOW JEDEN Z NICH, W INNYM WYPADKU WYKONAJ S=S+1

OGOLNIE TEN SEMAFOR DZIALA TROCHE JAK STOS W KOPROCESORZE

ISTNIEJE SEMAFOR BINARNY POSIADAJACY TYLKO DWIE WARTOSCI 0 I 1
WTEDY OPERACJA SIGNAL(S) POWODUJE ŻE S = 1

### CO TO ZNACZY ZE SEMAFOR JEST UCZCIWY, SLABO UCZCIWY

SEMAFOR JEST UCZCIWY GDY OD PEWNEGO MIEJSCA DZIALANIA PROCESU OPERACJA SIGNAL(S) JEST WYKONYWANA NIESKONCZENIE WIELE RAZY TO W KONCU KAZDY OCZEKUJACY PROCES ZOSTANIE WZNOWIONY I WYKONA OPERACJE WAIT(S) NA KTOREJ BYL WSTRZYMANY

SEMAFOR JEST SLABO UCZCIWY GDY OD PEWNEGO MIEJSCA DZIALANIA PROCESU WARTOSC SEMAFORA JEST STALE WIEKSZA OD ZERA TO W KONCU PROCES WSTRZYMANY NA TYM ZOSTANIE WZNOWIONY I WYKONA OPERACJE WAIT(S) NA KTOREJ BYL WSTRZYMANY

### REALIZACJA WZAJEMNEGO WYKLUCZANIA PRZY UZYCIU SEMAFOROW

P_i:
    while true
        sekcja_lokalna_i
        wait(S)
        sekcja_krytyczna_i
        signal(S)

### MECHANIZM DZIALANIA KOLEJEK FIFO

KOLEJKI FIRST IN FIRST OUT

ZAPIS/ODCZYT ORAZ USUNIECIE ODBYWAJA SIE DLA KOLEJKI FIFO TAK SAMO JAK DLA ZWYKLEGO PLIKU (MOGA TO ROBIC WSZYSTKIE PROCESY KTORE MAJA PRAWA DOSTEPU DO KOLEJKI)
MUSI ZACHODZIC SYNCHRONIZACJA OPERACJI ZAPISU I ODCZYTU CZYLI:

- JEZELI PROCES PROBUJE CZYTAC Z PUSTEGO LACZA TO READ() JEST ZABLOKOWANY AZ POJAWIA SIE DANE DO ODCZYTU

- JEZELI PROCES PROBUJE PISAC DO PELNEGO LACZA TO WRITE() JEST ZABLOKOWANY AZ ODCZYTY ZROBIA TYLE MIEJSCA ZEBY ZMIESCIL SIE CALY ZAPIS

FLAGA O_NDELAY W FUNKCJI OPEN WPLYWA NA ZACHOWANIE FUNKCJI READ() WRITE()

WTEDY READ() PRZY PROBIE ODCZYTY BEZ OTWARTEJ KOLEJKI DO ZAPISU ZWROCI 0(KONIEC PLIKU)
WRITE() JEZELI ZADEN PROCES NIE JEST PODLACZANY DO ODCZYTU SPOWODUJE WYGENEROWANIE SYGNALU SIGPIPE DOPROWADZI TO DO ZAKONCZENIA DZIALANIA PROCESU O ILE SYGNAL NIE ZOSTANIE OBSLUZONY

ILOSC DANYCH ZAWARTYCH KOLEJCE FIFO OGRANICZA SYSTEM OPERACYJNY

KIEDY KOLEJKA NIE JEST SKOJARZONA Z PROCESEM JEJ ZAWARTOSC JEST ZEROWANA

WSZYSTKIE PROCESY ZAANGAZOWANE W KOMUNIKACJE MUSZA ZNAC NAZWY KOLEJEK PRZED ROZPOCZECIEM KOMUNIKACJI

NIE MOZNA ZIDENYFIKOWAC PROCESU ZAPISUJACEGO DANE, JEDYNIE JESLI PROCES SAM ZAPISZE TO W DANYCH

W PYTHONIE MOZNA OPEROWAC NA KOLEJKACH FUNKCJAMI PYTHONA (OPEN, READ, WRITE)
 
## OBSLUGA SYGNALOW

KILL -SYGNAL ID WYSYLA SYGNAL DO PROCESU O ID (NP KILL -9 ID)
RTAP KOMENDA SYGNAL (PRZECHWYCA PRZESYLANY SYGNAL I WYKONUJE KOMENDE)

### ROZUMIEC DZIALANIE FUNKCJI SIGNAL W PYTHONIE

SIGNAL.SIGNAL(SIGNALNUM, HANDLER)

HANDLER(SIGNUM, FRAME)

HANDLER TO FUNKCJA KTORA ZDEFINIOWALISMY, OBSLUGUJE ONA POJAWIONY SIE SYGNAL(WYWOLUJE SIE AUTOMATYCZNIE PO POJAWIENIU SIE SYGNALU)
FRAME TO RAMKA STOSU

MODUL SIGNAL DEFINIUJE STALE OZNACZAJACE NUMERY SYGNALOW
SIGNAL.SIGUSR1 = SYGNAL ZDEFINIOWANY PRZEZ UZYTKOWNIKA
SIGNAL.SIGTERM = SYGNAL PRZERWANIA Z KLAWIATURY CTRL + C

HANDLEREM MOGA BYC SPECJALNE WARTOSCI

SIGNAL.SIG_IGN = IGNOROWANIE SYGNALU
SIGNAL.SIG_DFL = OBSLUGA DOMYSLNA

### JAK ZROBIC OBSLUGE W PYTONGU

```PYTHON
import signal, os
def handler(signum, frame):
    print('Obsługa sygnału ', signum)
# przypisanie obsługi sygnału do SIGINT
signal.signal(signal.SIGINT, handler)
while True:
    pass

import signal, sys
def handler(signum, frame):
    print(' Obsługa sygnału ', signum)
def handler1(signum, frame):
    print(' Inna obsługa sygnału ', signum)
    sys.exit(0)
# przypisanie obsługi sygnału do SIGINT
signal.signal(signal.SIGINT, handler)
# przypisanie obsługi sygnału do SIGUSR!
signal.signal(signal.SIGUSR1, handler1)
while True:
    pass
```

## KOLEJKI KOMUNIKATOW IPC

MUSI BYC UTWORZONA PRZED UZYCIEM
MUSI MIEC WLASCICIELA I PRAWACH DOSTEPU

IPCRM Z ODPOWIEDNIMI FLAGAMI I PARAMETRAMI USUWA OBIEKTY IPC

### ZINTERPRETOWANIE WYDRUKU KOMENDY IPCS -B

IPCS -B WYSWIETLA INFORMACJE O AKTUALNYCH OBIEKTACH IPC

MAMY:
MESSAGE QUEUES
KEY - MSQID - OWNER - PERMS - USED-BYTES MESSAGES
SHARED MEMORY SEGMENTS
KEY - SHMID - OWNER - PERMS - BYTES - NATTCH - STATUS
SEMAPHORE ARRAYS
KEY - SEMID - OWNER - PERMS - NSESM
KEY TO WARTOSC HEXAGONALNA 0X....
PERMS TO JAK PRAWA DOSTEPU DO PLIKU XXX NP 600
OWNER TO USER
STATUS TO NO CLUE JA MAM DEST XD

IPCS BEZ B WYDRUKOWALO MI TO SAMO

### MECHANIZM DZIALANIA KOLEJEK KOMUNIKATOW IPC (MODUL SYSV_IPC)

TWORZYMY NOWA KOLEJKE ICP ALBO OTWIERAMY ISTNIEJACA:

MessageQueue(key, [flags = 0, [mode = 0600,
[max_message_size = 2048]]]

KEY MOZE BYC NONE, IPC_PRIVATE LUB INT > 0 (ALE <= KEYMAX)
JEZELI KEY JEST NONE TO WYBIERANY JEST LOSOWY NEIZAJETY NUMER

FLAGI SPECYFIKUJA CZY BEDZIE OTWIERANA NOWA KOLEJKA, ALBO ISTNIEJACA
0 - ISTNIEJACA (EXISTENTIALERROR JEZELI NIE ISTNIEJE)
IPC_CREAT - TWORZY NOWA ALBO OTWIERA ISTNIEJACA
IPC_CREX (IPC_CREAT | IPC_EXCL) - TWORZYY NOWA (EXISTENTIALERROR JEZELI ISTNIEJE)

REMOVE() = USUWA KOLEJKE KOMUNIKATOW

#### FUNKCJA SEND

send(message, [block = True, [type = 1]])

MESSAGE JEST TO OBIEKT BAJTOWY

BLOCK SPECYFIKUJE CZY WYSYLANIE JEST BLOKUJACE (GDY KOLEJKA JEST FULL) CZY ZGLOSI BLAD BUSYERROR

TYPE JEST TYPEM PRZYPISANYM KOMUNIKATOWI > 0

#### FUNKCJA RECIEVE

receive([block = True, [type = 0]])

BLOCK SPECYFIKUJE CZY ODBIERANIE JEST BLOKUJACE (GDY NIE MA KOMUNIKATU DANEGO TYPU) CZY ZGLOSI BLAD BUSYERROR

TYPE:
0 - ODEBRANIE PIERWSZEGO KOMUNIKATU Z KOLEJKI NIE ZWAZAJAC NA TYP
'>' 0 - POBIERA PIERWSZY KOMUNIKAT DANEGO TYPU
'<' 0 - POBIERA PIERWSZY KOMUNIKAT TYPU MNIEJSZEGO NIZ ROWNEGO TYPE CO DO WARTOSCI BEZWZGLEDNEJ

### SZCZEGOLY PRZYKLADOW IPC

PREZENTACJA WSPOLB6P KEY SLAJDY OD 16

### MECHANIZM DZIALANIA PAMIECI WSPOLNEJ I SEMAFOROW IPC

PROCES MOZE MIEC DODATKOWO W TRAKCIE WYKONYWANIA PRZYDZIELONE OBSZARY PAMIECI Z PRZESTRZENI DOSTEPNEJ WSZYSTKIM PROCESOM

SharedMemory(key, [flags = 0, [mode = 0600, [size = 0 or PAGE_SIZE,
[init_character = ' ']]]])

### ZNACZENIE PARAMETRU KEY I FLAG

KEY, FLAGS, MODE SA TAKIE SAME JAK W KOLEJKACH IPC

### DZIALANIE FUNKCJI OPERUJACYCH NA PAMIECI WSPOLNEJ I SEMAFORACH

mem = sysv_ipc.SharedMemory(klucz, sysv_ipc.IPC_CREX)
PODPINA PROCES DO WSPOLDZIELONEJ PAMIECI

read([byte_count = 0, [offset = 0]])
READ CZYTA NIE WIECEJ BAJTOW NIZ BYTE COUNT Z SEGMENTOW PAMIECI ZACZYNAJAC OD OFFSET I ZWRACA JE JAKO OBIEKT BYTEOWY
JESLI BYTE COUNT JEST ZERO TO ZWRACA CALY BUFOR

write([bytes = 0, [offset = 0]])
WRITE WPISUJE OBIEKT BAJTOWY BYTES DO SEGMENTU PAMIECI ZACZYNAJAC OD OFFSET

detach()
ODLACZA PROCES OD WSPOLDZIELONEJ PAMIECI

remove()
USUWA WSPOLDZIELONA PAMIEC ALE DOPIERO GDY WSZYSTKIE PROCESY KTORE JEJ UZYWAJA SIE ZAKONCZA

```PYTHON
import sysv_ipc
klucz = 11
NULL_CHAR = '\0'
mem = sysv_ipc.SharedMemory(klucz, sysv_ipc.IPC_CREX)
def pisz(mem, s):
    s += NULL_CHAR
    s = s.encode()
    mem.write(s)

s = 'aaaaa'
pisz(mem,s)
```

## GNIAZDA DATAGRAMOWE

GNIAZDA(SOCKETY)
MOGA BYC TWORZONE W DOMENACH
UNIKSOWYCH(LOKALNYCH)
INTERNETOWYCH

### SCHEMAT KOMUNIKACJI PRZEZ GNIAZDA DATAGRAMOWE (UDP)

BIND(ADRESS)
ZWIAZUJEMY GNIAZDO Z NIEZWIAZANYM ADRESEM, ADRES TO PARA:
ADRES LOKALNY I NUMER PORTU

CLOSE() ZAMYKA GNIAZDO

SCHEMAT
SERVER TWORZY SWOJ SOCKET: SOCKET()
KLIENT TWORZY SWOJ SOCKET: SOCKET()
OBOJE BINDUJA SWOJE ADRESY: BIND()
SERWER ODBIERA DANE: RECVFROM()
KLIENT WYSYLA DANE: SENDTO()
I SZYKUJE SIE NA ODBIERANIE: RECVFROM()
SERWER JAK OTRZYMA DANE TO JE WYSYLA: SENDTO()

recvfrom(bufsize[, flags])

BUFSIZE = MAKSYMALNA ILOSC POBIERANYCH BAJTOW (OBCINAMY DO TEJ WIELKOSCI)
FLAGS = Flagi, typowo 0 (może być MSG_OOB (poza kolejnością) MSG_PEEK)

ZWRACA PARE (BYTES, ADDRESS)
BYTES = OBIEKT BAJTOWY BEDACY ODEBRANYM KOMUNIKATEM
ADDRESS = PARA IP + PORT

sendto(bytes, address)
sendto(bytes, flags, address)

## WATKI WSPOLBIEZNE (THREADING)

WATEK FUNKCJONUJE W RAMACH PROCESU I UZYWA JEGO ZASOBY
MOZE WSPOLDZIELIC ZASOBY PROCESU Z INNYMI WATKAMI
DUPLIKUJE TYLKO NIELICZNE ZASOBY PROCESU KTORYCH POTRZEBUJE DO NIEZALEZNEGO DZIALANIA
GINIE GDY JEGO PROCES ZNIKA

### SPOSOB TWORZENIA WATKOW W MODULE THREADING

class threading.Thread(group=None, target=None,
name=None, args=(), kwargs={}, *, daemon=None)

GROUP = NIEUZYWANY
TARKET = FUNKCJA KTORA WATEK MA WYKONAC
NAME = NAZWA WATKU
ARGS = LISTA ARGUMENTOW POZYCYJNYCH DLA FUNKCJI TARGET
KWARGS = SLOWNIK ARGUMENTOW KLUCZOWYCH DLA FUNKCJI TARGET
DAEMON = INFORMACJA CZY WATEK MA BYC DEMONEM

START() = URUCHAMIA WATEK

W.START()

### MECHANIZM WCIELANIA WATKOW (JOIN)

JOIN(TIMEOUT=NONE)
TIMEOUT = CZAS PO KTORYM OCZEKIWANIE ZOSTANIE PRZERWANE

W.JOIN()

```PYTHON
import threading
import time
def f(arg,name,s):
    for i in range(arg):
        print(name,'i=',i)
        time.sleep(s)
t1 = threading.Thread(target = f, args = (5,'t1',1))
t2 = threading.Thread(target = f, args = (5,'t2',0.7))
t1.start()
t2.start()
t1.join()
t2.join()
print ("koniec")
```

SZYBCIEJ WYPISZE T2 NIZ T1 ZE WZGLEDU NA MNIEJSZY SLEEP
t1 i= 0
t2 i= 0
t2 i= 1
t1 i= 1
t2 i= 2
t1 i= 2
t2 i= 3
t2 i= 4
t1 i= 3
t1 i= 4

### MECHANIZM SYNCHRONIZACJI PRZEZ ZAMKI (LOCK)

CLASS THREADING.LOCK

LOCK TO RODZAJ SEMAFORA BINARNEGO (OTWARTY/ZAMKNIETY, ODBLOKOWANY/ZABLOKOWANY)

ACQUIRE(BLOCKING=TRUE, TIMEOUT=-1)

PRZEJMUJE ZAMEK BLOKUJACO/NIEBLOKUJACO

BLOCKING TRUE = BLOKUJE SIE DOPOKO ZAMEK NIE BEDZIE ODBLOKOWANY PO CZYM PRZEJMUJE ZAMEK I GO BLOKUJE, W WYNIKU ZWRACA TRUE

BLOCKING FALSE = NIE BLOKUJE SIE TYLKO ZWRACA FALSE GDY ZAMEK JEST ZABLOKOWANY I NIE MOZNA GO PRZEJAC, W PRZECIWNYM WYPADKU PRZEJMUJE GO I BLOKUJE I ZWRACA W WYNIKU TRUE

TIMEOUT OZNACZA MAKSYMALNY CZAS CZEKANIA NA ODBLOKOWANIE ZAMKA -1 OZNACZA NIESKONCZONE OCZEKIWANIE

RELEASE()
ZWALNIA ZAMEK, MOZE BYC TO WYWOLANE PRZEZ DOWOLNY WATEK, NIE TEN KTORY NALOZYL BLOKADE, JEZELI JAKIES WATKI CZEKAJA ZABLOKOWANE NA TYM ZAMKU JEDEN Z NICH ZOSTAJE ODBLOKOWANY I ZNOW BLOKUJE ZAMEK

WYWOLANIE RELEASE NA NIEZABLOKOWANYM WATKU POWODUJE RUNTIMEERROR

LOCKED()
ZWRACA TRUE JEZELI ZAMEK JEST W STANIE ZAMKNIETYM

class threading.RLock
RLOCK TO TAKI LOCK ALE MA DWIE ROZNICE
WATEK MOZE WIELOKROTNIE BLOKOWAC TEN SAM ZAMEK A ODBLOKOWANIE NASTAPI PO TEJ SAMEJ ILOSCI ODBLOKOWAN

WATEK KTORY ZABLOKOWAL ZAMEK PRZEJMUJE GO I TYLKO ON MOZE GO ODBLOKOWYWAC

acquire(blocking=True, timeout=-1)
BEZ ARGUMENTOW:

- JEZELI ZAMEK JEST ODBLOKOWANY PRZEJMUJE GO I BLOKUJE
- JEZELI BYL JUZ PRZEJETY PRZEZ TEN KTORY WYWOLUJE ACQUIRE TO ZWIEKSZA LICZNIK BLOKAD O 1
- JEZELI ZAMEK JEST PRZEJETY PRZEZ INNY WATEK TO BLOKUJE SIE AZ ZAMEK NIE BEDZIE ODBLOKOWANY PO CZYM PRZEJMUJE GO I BLOKUJE
- W KAZDEJ SYTUACJI NIE ZWRACA WYNIKU

BLOCKING TRUE: JEDYNIE DODATKOWO ZWRACA W WYNIKU TRUE
BLOCKING FALSE: NIE BLOKUJE SIE TYLKO ZWRACA OD RAZU FALSE GDY ZAMEK JEST ZABLOKOWANY I NIE MOZNA GO PRZEJAC. W PRZECIWNYM WYPADKU DZIALA JAK BEZ ARGUMENTOW I W WYNIKU ZWRACA TRUE

RELEASE()
ZMNIEJSZA LICZBE BLOKAD O 1, JEZELI BLOKADY DOJDA DO 0 TO ZWALNIA ZAMEK I JEZELI JAKIES WATKI CZEKAJA ZABLOKOWANE NA TYM ZAMKU TO JEDEN Z NICH JEST ODBLOKOWYWANY, PRZEJMUJE ZAMEK I ZNOWU GO BLOKUJE

WYWOLANIE RELEASE() NA NIEZABLOKOWANYM ZAMKU POWODUJE RUNTIMEERROR

### SYNCHRONIZOWANIE WATKOW ZA POMOCA BARIERY

class threading.Barrier(parties, action=None,
timeout=None)

TWORZY BARIERE DLA ILOSCI WATKOW (PARTIES)
PARAMETR ACTION TO FUNKCJA WYWOLOWANA PRZEZ JEDEN Z WATKOW PO PRZEKROCZENIU BARIERY

WAIT(TIMEOUT=None)
CZEKANIE NA DOJSCIE DO BARIERY PRZEZ WSZYSTKIE WATKI

```PYTHON
# utworzenie dwóch wątków współbieżnych wykonującyh
# funkcję f
# synchronizacja barierą
import threading
import time
def f(arg,name,s,bar):
    for i in range(arg):
        print(name,'i=',i)
        time.sleep(s)
    print ("koniec pracy "+name)
    bar.wait()
    print ("koniec czekania "+name)
b = threading.Barrier(3)
t1 = threading.Thread(target = f, args = (5,'t1',1,b))
t2 = threading.Thread(target = f, args = (2,'t2',0.7,b))
t1.start()
t2.start()
print ("koniec pracy ")
b.wait()
# t1.join()
# t2.join()
print ("koniec czekania")
```

RUNTIME:
t1 i= 0
t2 i= 0
koniec pracy
t2 i= 1
t1 i= 1
koniec pracy t2
t1 i= 2
t1 i= 3
t1 i= 4
koniec pracy t1
koniec czekania t1
koniec czekania
koniec czekania t2

### MECHANIZM ZMIENNYCH WARUKOW

CONDITION VARIABLE

class threading.Condition(lock=None)

TWORZY ZMIENNA WARUNKU NA KTOREJ JEDEN LUB WIECEJ WATKOW MOZE CZEKAC DO CZASU POWIADOMIENIA PRZEZ INNE WATKI O MOZLIWOSCI WZNOWIENIA DZIALANIA

PARAMETR LOCK JEST OBIEKTEM TYPU LOCK LUB RLOCK KTORY MUSI BYC OBOWIAZKOWO SKOJARZONY ZE ZMIENNA WARUNKU. JAK POMINIEMY TO AUTOMATYCZNIE TWORZY NAM LOCK

ACQUIRE(*ARGS) BLOKUJE ZAMEK SKOJARZONY ZE ZMIENNA WARUNKU

RELEASE() ZWALNIA ZAMEK SKOJARZONY ZE ZMIENNA WARUNKU

WAIT(timeout=None) CZEKA AZ DO POWIADOMIENIA PRZEZ INNY PROCES O MOZLIWOSCI WZNOWIENIA DO CZASU TIMEOUT.
JEZELI WCZESNIEJ NIE ZROBILISMY ACQUIRE() NA ZAMKU SKOJARZONYM ZE ZMIENNA WARUNKU ZGLASZA RUNTIMEERROR. PRZED WEJSCIEM W STAN CZEKANIA ZWALNIA I ODBLOKOWUJE ZAMEK SKOJARZONY ZE ZMIENNA WARUNKU, PO WZNOWIENIU LUB PO TIMEOUT ZNOWU BLOKUJE ZAMEK I W TYM STANIE ROBI RETURN

WAIT_FOR(PREDICATE, TIMEOUT=NONE) CZEKA AZ FUNKCJA PREDICATE() OTRZYMA WARTOSC TRUE ALBO AZ PRZEKROCZY CZAS TIMEOUT, TA METODA MOZE WIELOKROTNIE WYWOLYWAC WAIT() ORAZ METODE PREDICATE() W CELU SPRAWDZENIA JEJ WARTOSCI

NOTIFY(N=1) AKTYWUJE N WATKOW CZEKAJACYCH NA TEJ ZMIENNEJ WARUNKU (DOMYSLNIE 1 WATEK) JEZELI WCZESNEJ NIE ZROBILISMY ACQUIRE() NA ZAMKU SKOJARZONYM ZE ZMIENNA WARUNKU DOSTAJEMY RUNTIMEERROR

AKTYWOWANY WATEK NIE RUSZA ODRAZU ALE DOPIERO GDY ZABLOKUJE SIE ZAMEK SKOJARZONY ZE ZMIENNA WARUNKU. WATEK KTORY WYWOLAL NOTIFY() POWINIEN ZWOLNIC TEN ZAMEK

NOTIFY_ALL() AKTYWUJE WSZYSTKIE WATKI CZEKAJACE NA WARUNKU

ZASTOSOWANIE DO PROBLEMU PRODUCENT-KONSUMENT:

```PYTHON
# Skonsumuj element
cv.acquire():
while not elementDostępny():
    cv.wait()
pobierzElement()
cv.release()
# Produkuj element
cv.acquire()
udostępnijElement()
cv.notify()
cv.release()
```

## PROBLEM PRODUCENT-KONSUMENT

PRODUCENT TWORZY ZESTAWY DANYCH KTORE PRZESYLA DO KONSUMENTA
KONSUMENT ODBIERA ZESTAWY DANYCH KTORE NASTEPNIE PRZETWARZA

KOMUNIKACJA MOZE BYC SYNCHRONICZNA BADZ ASYNCHRONICZNA
W WPADKU ASYNC POTRZEBNY JEST BUFOR NA SKLADOWANIE PRZESYLANYCH DANYCH

PRZYKLAD: wspolb10ProdKonPdf slajd 6

## MECHANIZMY WYZSZEGO POZIOMU

### SPOSOB TWORZENIA WATKOW W MULTIPROCESSING POOL (multiprocessing.Pool)

TWORZENIE
pool = multiprocessing.pool.Pool(...)
PO SKONFIGUROWANIU MOZEMY SUBMITOWAC TASKI UZYWAJAC BLOKOWANIA I ASYNCHRONICZNYCH WERSJI APPLY() I MAP()
results = pool.map(task, items)
A PO ZAKONCZENIU DZIALANIA Z PROCESEM POOL ZAMYKAMY GO I ZWALNIAMY ZASOBY UZYWANE PRZEZ NIEGO
pool.close()

LIFECYCLE TAKIEGO POOLA

CREATE -> SUBMIT -> WAIT -> SHUTDOWN
WAIT: RESLUT.WAIT(), RESULT.GET()

### SPOSOB UZYCIA KOLEJKI QUEUE (queue.Queue)

q = queue.Queue()

MAMY PRACOWNIKA KTORY WHILE TRUE ZDEJMUJE PRZEDMIOTY Z KOLEJKI item = q.get(), COS TAM SE Z NIMI ROBI I KIEDY SKONCZY Z TYM PRZEDMIOTEM ROBI q.task_done()

JAK CHCEMY COS WSTAWIC DO KOLEJKI TO ROBIMY q.put(item)

TAKIE DZIALANIE TO NP:

```PYTHON
import threading
import queue

q = queue.Queue()

def worker():
    while True:
        item = q.get()
        print(f'Pracuje na {item}')
        print(f'Skonczylem {item}')
        q.task_done()

threading.Thread(target=worker, daemon=True).start()

#wysylamy 30 taskow do workera
for item in range(30):
    q.put(item)

#blokujemy dopoki taski nie beda skonczone
q.join()
print('Koniec pracy')
```

### PROBLEM PIECIU FILOZOFOW

PIECIU FILOZOFOW SOBIE SIEDZI DOOKOLA OKRAGLEGO STOLU KAZDEGO Z NICH DZIELA WIDELCE
ZEBY JESC MUSI WZIAC DWA WIDELCE

F_i:
    while true
        myślenie_i
        weź_dwa_widelce
        jedzenie_i
        odłóż_dwa widelce

FILOZOF POTRZEBUJE DWOCH WIDELCOW ZEBY JESC
DWOCH GOSCI NIE MOZE UZYWAC TEGO SAMEGO WIDELCA JEDNOCZESNIE
FILOZOF MOZE BRAC TYLKO WIDELCE OBOK SIEBIE I TO POJEDYNCZO

WYMAGANE WLASNOSCI:

- DWOCH FILOZOFOW NIE MOZE JEDNOCZESNIE TRZYMAC TEGO SAMEGO WIDELCA
- BRAK BLOKADY
- NIKT NIE MOZE BYC ZAGLODZONY
- EFEKTYWNE ZACHOWANIE PRZY BRAKU WSPOLZAWODNICTWA

ROZWIAZANIE: wspolb10p5filoz slajd 8
WHILE TRUE FILOZOF MYSLI
NASTEPNIE CZEKA AZ ZWOLNI SIE WIDELEC LEWY
POTEM AZ ZWOLNI SIE PRAWY
WCINA
SYGNALIZJE ZE ZWOLNIL SIE PRAWY
SYGNALIZUJE ZE ZWOLNIL SIE LEWY

#### PROBLEMY W TYM PROBLEMIE

WSPOLB10P5FILOZ (CALY PDF)

##### BLOKADA
 
SLAJD 5

##### ZLAGODZENIE

SLAJDY 6 I 7

## MULTIPROCESSING - WSPOLDZIELONA PAMIEC

multiprocessing.Value(typecode_or_type, *args, lock=True)
Zwraca obiekt typu ctypes alokowany we współdzielonej pamięci. Obiekt ten jest
automatycznie udostępniany na zasadzie wzajemnego wykluczania realizowanego
przez zamek lock podany w argumencie (Lock lub Rlock). W przypadku
pominięcia argumentu z zamkiem tworzony jest automatycznie anonimowy zamek.
Wartość we wspólnej pamięci jest dostępna przez pole value utworzonego
obiektu.
Argument typecode_or_type określa typ współdzielonej wartości,
np. c_double, c_int

multiprocessing.Array(typecode_or_type, size_or_initializer,
*, lock=True)
Podobnie jak Value, ale zwraca obiekt opakowujący tablicę wartości. Argument
size_or_initializer definiuje długość tej tablicy.

### PROBLEM CZYTELNIKOW I PISARZY

CZYTELNICY ODCZYTUJA DANE ZAPISANE PRZEZ PISARZY, NIE WYKLUCZAJA SIE WZAJEMNIE

PISARZE TWORZA DANE I ZAPISUJA, WYKLUCZAJA SIE WZAJEMNIE I WYKLUCZAJA CZYTELNIKOW

CZYTELNIK
    WHILE TRUE
    ZACZNIJ_CZYTANIE()
    CZYTAJ      <- PUNKT KRYTYCZNY
    ZAKONCZ_CZYTANIE()

PISARZ
    WHILE TRUE
    ZACZNIJ_PISANIE()
    PISZ       <- PUNKT KRYTYCZNY
    ZAKONCZ_PISANIE()

ROZWIAZUJEMY TO Z MONITOREM
MONITOR MA DWA WARUNKI
MOZNA PISAC, MOZNA CZYTAC
ILOSC CZYTELNIKOW
CZYTELNICY = 0
CZY JEST PISANED
PISANIE = FALSE

zacznij_czytanie()
    if pisanie or nonempty(możnaPisać)
        wait(możnaCzytać)
    czytelnicy = czytelnicy +1
    signal(możnaCzytać)

zakończ_czytanie()
    czytelnicy = czytelnicy-1
    if czytelnicy == 0
        signal(możnaPisać)zacznij_pisanie()

zacznij_pisanie()
    if czytelnicy != 0 or pisanie
        wait(możnaPisać)
    pisanie = true

koniec_pisania()
    pisanie = false
    if nonempty(możnaCzytać)
        signal(możnaCzytać)
    else
        signal(możnaPisać)

### KONCEPCJA MONITORA

```txt
monitor M
    warunki w, w1, w2, ...

    zmienne

    funkcja1():
        ...
        wait(w)
        ...

    funkcja2():
        ...
        signal(w)
        ...
```

FUNKCJE MONITORA WYKONUJA SIE NA ZASADZIE WZAJEMNEGO WYKLUCZANIA

DOSTEP DO ZMIENNYCH MONITORA DZIALA NA ZASADZIE W ZAJEMNEGO WYKLUCZANIA

WAIT(W) ZAWIESZA PROCES I ZWALNIA MONITOR DO CZASU GDY INNY PROCES WYKONA SIGNAL(W)

SIGNAL(W) WZNAWIA JEDEN Z PROCESOW CZEKAJACYCH NA WARUNKU W

## GNIAZDA TCP (SOCK_STREAM, POLACZENIOWE)

SERVER                                      KLIENT
TWORZY GNIAZDO: SOCKET()                    SOCKET()
PRZYPISUJE GNIAZDU ADRES: BIND()
INICJALIZUJE KOLEJKE POLACZEN: LISTEN()
POBIERA POLACZENIE: ACCEPT()                INICJALIZUJE POLACZENIE: CONNECT()
RECV()                                      SEND()
SEND()                                      RECV()

ODBIERANIE JEST ZAZWYCZAJ BLOKUJACE ( CZEKAMY NA POJAWIENIE SIE DANYCH W GNIEZDZIE )
recv(bufsize[, flags])

## PROBLEM BIZANTYJSKICH GENERALOW

GENERALOWIE TO PROCESORY
SA TEZ IMPOSTORZY CZYLI WADLIWE PROCESORY KTORZY ROBIA ROZNIE:
PRZESTAJA DZIALAC, WYSYLAJA PRZEKLAMANE WIADOMOSCI

CELEM SYSTEMU ROZPROSZONEGO JEST UZGODNIENIE PEWNEJ WARTOSCI 0 LUB 1 ABY KAZDY POPRAWNIE DZIALAJACY PROCESOR USTALIL TA SAMA WARTOSC
DLA GENERALOW OZNACZA TO (1:ATAK 0:ODWROT)

LACZNOSC JEST NIEZAWODNA KAZDY WIE OD KOGO POCHODZA WIADOMOSCI, JESLI ZDRAJCA NIE WYSLE WIADOMOSCI TRAKTUJEMY TO JAKO WIADOMOSC O WARTOSCI 0

WYKONUJE SIE PARE RUND KOMUNIKACJI ABY USTALIC DECYZJE

WSZYSCY LOJALNI CREWMATES WYKONAJA TEN SAM ROZKAZ POCHODZACY Z GORY
JEZELI GENERAL JEST GIT TO WSZYSCY GIT GOSTKOWIE WYKONAJA TEN ROZKAZ

NIE DA SIE ROZWIAZAC TEGO PROBLEMU DLA DWOCH SZTYWNYCH GITOW I JEDNEGO IMPOSTORA

```TXT
    GIT
|1      \1
GIT<-0-NIEGIT

   NIEGIT
 |1      \0
GIT <-0- GIT
```

TAK SAMO NIE DA SIE ROZWIAZAC JEZELI MAMY ROZKLAD 1 ZDRAJCA 2 GENERALOW
CZYLI 2 IMPOSTOROW 4 GENERALOW, ZASADY NICZYM W AMONGU NA 6 ZAWSZE MUSIMY KOGOS WYGLOSOWAC

W INNYM WYPADKU GOSTKOWIE POROZUMIEWAJAC SIE ZE SOBA ZAWSZE DOJDA DO WNIOSKU KTORA WIADOMOSC BYLA GIT I WYGLOSUJA IMPOSTORA
PREZENTACJA: WSPOLB12 SLAJDY 9 DO 12

## PRZYKLAD ZROWNOLEGLENIA ALGORYTMU SEKWENCYJNEGO (WIELOWATKOWE SORTOWANIE PRZEZ SCALANIE)

MERGE SORT: PREZENTACJA WSPOLB13MERGE SLAJDY OD 5

```TXT
Wielowątkowe scalanie
Idea:
• W większej ze scalanych tablic wybieramy element środkowy x
(jest ona posortowana, więc łatwo to zrobić). Dzieli on tę podta-
blicę na dwie części L1, R1 (elementu x nie dołączamy do żadnej
z tych części).
• W drugiej tablicy używamy szukania binarnego do znalezienia
takiej pozycji, że po jednej stronie są elementy mniejsze równe
x a po drugiej większe. Mamy więc też podział na dwie części:
L2, R2.
• Scalamy rekurencyjnie L1 z L2 oraz R1 z R2. Jedno z wywołań
rekurencyjnych robimy w nowym wątku.

WMerge(T,p1,r1,p2,r2,A,p3)
# scala posortowane podtablice T[p1...r1] i T[p2...r2]
# wynik jest wpisany do tablic A zaczynając od pozycji p3
    n1=r1-p1+1
    n2=r2-p2+1
    if n1<n2
        zamień n1,r1,p1 z n2,r2,p2
    if n1==0
        return #obie tablice puste
    q1 = floor((p1+r1)/2) # środkowa pozycja w T[p1...r1]
    q2 = BinarySearch(T[q1],T,p2,r2)
    q3 = p3+(q1-p1)+(q2-p2)
    # do A[p3...q3-1] scalone będą T[p1...q1-1} i T[p2...q2-1]
    A[q3]=T[q1]
    spawn WMerge(T,p1,q1-1,p2,q2-1,A,p3)
    WMerge(T,q1+1,r1,q2,r2,A,q3+1)
    sync

Stwierdzenie Pesymistyczny czas równoległy WMerge dla nieograni-
czonej ilości procesorów jest Θ((lg n)2 ), gdzie n to łączna ilość ele-
mentów w obu scalanych tablicach.
Idea dowodu
Niech T∞ (n) oznacza czas równoległy WMerge dla nieograniczonej ilo-
ści procesorów.
W najgorszym przypadku maksymalna ilść elementów w każdym z
obydwóch wywołań rekurencyjnych jest 3n/4, bo w każdej z dwóch
par scalanych podtablic jedna podtablica ma nie więcej niż n/2 ele-
mentów a druga nie więcj niż n/4.
Mamy zatem zależność rekurencyjną:
T∞ (n) = T∞ (3n/4) + Θ(lg n)
T∞ (1) = c1 , dla pewnej stałej c1
Przez indukcję ze względu na n można sprawdzić, że w takiej sytuacji
T∞ (n) = Θ((lg n)2 ).

Wielowątkowe sortowanie przez scalanie
W prymitywnym wielowątkowym sortowaniu przez scalanie zastępu-
jemy sekwencyjne scalanie scalaniem wielowątkowym, dopracowując
odpowiednio szczegóły.

WMergeSort(A,p,r,B,s)
# sortuje podtablicę A od pozycji p do pozycji r, czyli A[p...r], ale
# wynik sortowania jest nie w tablicy A a w tablicy B
# zaczynając od pozycji s
    n = r-p+1
    if n==1
        B[s]=A[p]
    else
        utworz pomocniczą tablicę T[1...n]
        q = floor((p+r)/2)
        nq = q-p+1
        spawn WMergeSort(A,p,q,T,1)
        WMergeSort(A,q+1,r,T,nq+1)
        sync
        WMerge(T,1,nq,nq+1,n,B,s)

Stwierdzenie Pesymistyczny czas równoległy WMergeSort dla nie-
ograniczonej ilości procesorów jest Θ((lg n)3 ), gdzie n to rozmiar sor-
towanej tablicy.
Idea dowodu
Niech T∞ (n) oznacza czas pesymistyczny WMergeSort. Mamy zależ-
ność rekurencyjną:
T∞ (n) = T∞ (n/2) + Θ((lg n)2 )
T∞ (1) = c1 , dla pewnej stałej c1
Przez indukcję ze względu na n można sprawdzić, że w takiej sytuacji
T∞ (n) = Θ((lg n)3 ).

Uwaga W funkcjach WMerge i WMergeSort wywołania rekurencyjne
się kończą na jednoelementowych tablicach, co prowadzi do wywo-
łań rekurencyjnych i tworzenia osobnych wątków do obsługi nawet
malutkich podtablic. Rozsądne byłoby zmodyfikować te algorytmy
tak, żeby dla podtablic pewnego niedużego rozmiaru przechodziły na
zwykłe sekwencyjne wersje algorytmów a nawet nierekurencyjne.

```
